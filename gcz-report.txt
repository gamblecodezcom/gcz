=== GCZ FULL SYSTEM REPORT (2026-01-01T06:33:03+00:00) ===
Root: /var/www/html/gcz


=== HEALTH CHECKS ===

--- curl localhost:3000/api/health ---
{"status":"healthy","uptime":502.022838735}
--- curl https://gamblecodez.com/api/health ---
{"status":"healthy","uptime":502.084389537}
=== PM2 STATUS ===

--- pm2 list ---
┌────┬─────────────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ id │ name            │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
├────┼─────────────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤
│ 0  │ gcz-api         │ default     │ N/A     │ fork    │ 3939939  │ 8m     │ 398  │ online    │ 0%       │ 77.0mb   │ root     │ disabled │
│ 3  │ gcz-bot         │ default     │ N/A     │ fork    │ 3939886  │ 8m     │ 1060 │ online    │ 0%       │ 52.8mb   │ root     │ disabled │
│ 4  │ gcz-discord     │ default     │ N/A     │ fork    │ 3939902  │ 8m     │ 100… │ online    │ 0%       │ 84.5mb   │ root     │ disabled │
│ 2  │ gcz-redirect    │ default     │ N/A     │ fork    │ 3939922  │ 8m     │ 109  │ online    │ 0%       │ 42.5mb   │ root     │ disabled │
│ 1  │ gcz-watchdog    │ default     │ N/A     │ fork    │ 3939872  │ 8m     │ 107  │ online    │ 0%       │ 51.2mb   │ root     │ disabled │
└────┴─────────────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘

=== NGINX CONFIG: sites-enabled/gamblecodez ===

--- cat /etc/nginx/sites-enabled/gamblecodez ---
# GambleCodez Production Nginx Configuration
# Place this in /etc/nginx/sites-available/gamblecodez
# Then symlink: sudo ln -s /etc/nginx/sites-available/gamblecodez /etc/nginx/sites-enabled/
# Test: sudo nginx -t
# Reload: sudo systemctl reload nginx

# Rate limiting zones
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
limit_req_zone $binary_remote_addr zone=general_limit:10m rate=30r/s;

# Upstream backend
upstream gcz_backend {
    server 127.0.0.1:3000;
    keepalive 32;
}

# HTTP to HTTPS redirect
server {
    if ($host = www.gamblecodez.com) {
        return 301 https://$host$request_uri;
    } # managed by Certbot


    if ($host = gamblecodez.com) {
        return 301 https://$host$request_uri;
    } # managed by Certbot


    listen 80;
    listen [::]:80;
    server_name gamblecodez.com www.gamblecodez.com;
    
    # Let's Encrypt challenge
    location /.well-known/acme-challenge/ {
        root /var/www/html/gcz;
    }
    
    # Redirect all HTTP to HTTPS
    location / {
        return 301 https://$server_name$request_uri;
    }




}

# HTTPS server
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name gamblecodez.com www.gamblecodez.com;

    # SSL Configuration
    ssl_certificate /etc/letsencrypt/live/gamblecodez.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/gamblecodez.com/privkey.pem; # managed by Certbot
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_stapling on;
    ssl_stapling_verify on;

    # Security Headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https: wss:; frame-ancestors 'self';" always;

    # Root and index
    root /var/www/html/gcz/public;
    index index.html;

    # Logging
    access_log /var/log/nginx/gamblecodez-access.log;
    error_log /var/log/nginx/gamblecodez-error.log;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/rss+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml;
    gzip_disable "msie6";

    # Brotli compression (if available)
    # brotli on;
    # brotli_comp_level 6;
    # brotli_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/rss+xml;

    # Static assets caching
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        access_log off;
    }

    # Robots.txt and sitemap
    location = /robots.txt {
        root /var/www/html/gcz/frontend/public;
        access_log off;
    }

    location = /sitemap.xml {
        root /var/www/html/gcz/frontend/public;
        access_log off;
    }

    # API routes with rate limiting
    location /api/ {
        limit_req zone=api_limit burst=20 nodelay;
        limit_req_status 429;
        
        proxy_pass http://gcz_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 60s;
        proxy_connect_timeout 60s;
    }

    # WebSocket support for real-time updates
    location /socket.io/ {
        proxy_pass http://gcz_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_read_timeout 86400;
    }

    # Admin panel (restrict access if needed)
    location /admin {
        # Optional: Add IP whitelist here
        # allow 1.2.3.4;
        # deny all;
        
        proxy_pass http://gcz_backend;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Frontend SPA - serve index.html for all routes
    location / {
        limit_req zone=general_limit burst=50 nodelay;
        
        try_files $uri $uri/ /index.html;
        
        # Cache control for HTML
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
    }

    # Health check endpoint
    location /api/health {
        access_log off;
        proxy_pass http://gcz_backend;
        proxy_set_header Host $host;
    }

}

=== APP ENTRY (app.js or src/app.js) ===
[WARN] No app.js or src/app.js found

=== ROUTES: routes/api.js ===

--- routes/api.js (1-260) ---

// Drops endpoint (auto-added by goose-finisher)
router.get('/drops', async (req, res) => {
  try {
    const drops = await db.query('SELECT * FROM drop_promos ORDER BY created_at DESC LIMIT 50');
    res.json(drops.rows);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to load drops' });
  }
});

=== ROUTES: profile.js ===

--- routes/profile.js (1-260) ---
import express from "express";
import pool from "../utils/db.js";
import { getUserFromRequest, requireUser, requirePin } from "../middleware/userAuth.js";
import crypto from "crypto";

const router = express.Router();

/**
 * @typedef {Object} User
 * @property {string} id
 * @property {string} [username]
 * @property {string} [cwallet_id]
 * @property {string} [email]
 * @property {string} [telegram_username]
 * @property {string} [telegram_id]
 * @property {'US'|'NON_US'|'GLOBAL'} [jurisdiction]
 * @property {boolean} hasRaffleAccess
 * @property {boolean} newsletterAgreed
 */

/**
 * @typedef {Object} ProfileResponse
 * @property {User} user
 * @property {boolean} rafflePinSet
 */

/**
 * GET /api/profile
 * Get user profile
 * 
 * @route GET /api/profile
 * @returns {Promise<ProfileResponse>} 200 - Success response with user profile
 * @returns {Promise<{error: string, message?: string}>} 401 - Authentication required
 * @returns {Promise<{error: string, message: string}>} 403 - Account blacklisted
 * @returns {Promise<{error: string}>} 500 - Server error
 */
router.get("/", async (req, res) => {
  try {
    const user = await getUserFromRequest(req);
    
    if (!user) {
      return res.status(401).json({ error: "Authentication required" });
    }
    
    // Check blacklist
    const blacklistCheck = await pool.query(
      "SELECT * FROM blacklist WHERE user_id = $1",
      [user.user_id]
    );
    
    if (blacklistCheck.rows.length > 0) {
      return res.status(403).json({
        error: "Access denied",
        message: "Your account has been blacklisted"
      });
    }
    
    // Get linked sites count
    const linkedSitesResult = await pool.query(
      "SELECT COUNT(*) as count FROM user_linked_sites WHERE user_id = $1",
      [user.user_id]
    );
    
    // Get raffle entries count
    const raffleEntriesResult = await pool.query(
      "SELECT COUNT(*) as count FROM raffle_entries WHERE user_id = $1",
      [user.user_id]
    );
    
    // Check newsletter subscription
    const newsletterResult = await pool.query(
      "SELECT * FROM newsletter_subscribers WHERE user_id = $1 AND unsubscribed = false",
      [user.user_id]
    );
    
    res.status(200).json({
      user: {
        id: user.user_id,
        username: user.username || null,
        cwallet_id: user.cwallet_id || null,
        email: user.email || null,
        telegram_username: user.telegram_username || null,
        telegram_id: user.telegram_id || null,
        jurisdiction: user.jurisdiction || null,
        hasRaffleAccess: raffleEntriesResult.rows[0]?.count > 0 || false,
        newsletterAgreed: newsletterResult.rows.length > 0,
      },
      rafflePinSet: !!user.pin_hash,
    });
  } catch (error) {
    console.error("Error fetching profile:", error);
    res.status(500).json({ 
      error: "Failed to fetch profile",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});

/**
 * POST /api/profile/update
 * Update user profile
 * 
 * @route POST /api/profile/update
 * @param {Object} req.body
 * @param {string} [req.body.username] - New username
 * @param {string} [req.body.cwallet_id] - New Cwallet ID
 * @param {string} [req.body.email] - New email
 * @returns {Promise<{user: User}>} 200 - Success response with updated user
 * @returns {Promise<{error: string}>} 400 - No fields to update
 * @returns {Promise<{error: string}>} 401 - Authentication required
 * @returns {Promise<{error: string}>} 500 - Server error
 */
router.post("/update", requireUser, async (req, res) => {
  try {
    const { username, cwallet_id, email } = req.body;
    const userId = req.user.user_id;
    
    const updates = [];
    const values = [];
    let paramIndex = 1;
    
    if (username !== undefined) {
      updates.push(`username = $${paramIndex++}`);
      values.push(username);
    }
    
    if (cwallet_id !== undefined) {
      updates.push(`cwallet_id = $${paramIndex++}`);
      values.push(cwallet_id);
    }
    
    if (email !== undefined) {
      updates.push(`email = $${paramIndex++}`);
      values.push(email);
    }
    
    if (updates.length === 0) {
      return res.status(400).json({ error: "No fields to update" });
    }
    
    updates.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(userId);
    
    const query = `
      UPDATE users 
      SET ${updates.join(", ")}
      WHERE user_id = $${paramIndex}
      RETURNING *
    `;
    
    const result = await pool.query(query, values);
    
    // Log activity
    if (username !== undefined) {
      await pool.query(
        `INSERT INTO activity_log (user_id, activity_type, title, description, created_at)
         VALUES ($1, 'username_changed', 'Username Updated', 'Changed username to ' || $2, CURRENT_TIMESTAMP)`,
        [userId, username]
      );
    }
    
    if (cwallet_id !== undefined) {
      await pool.query(
        `INSERT INTO activity_log (user_id, activity_type, title, description, created_at)
         VALUES ($1, 'cwallet_updated', 'Cwallet Updated', 'Updated Cwallet ID', CURRENT_TIMESTAMP)`,
        [userId]
      );
    }
    
    res.status(200).json({
      user: {
        id: result.rows[0].user_id,
        username: result.rows[0].username,
        cwallet_id: result.rows[0].cwallet_id,
        email: result.rows[0].email,
      },
    });
  } catch (error) {
    console.error("Error updating profile:", error);
    res.status(500).json({ 
      error: "Failed to update profile",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});

/**
 * POST /api/profile/pin
 * Set raffle PIN
 * 
 * @route POST /api/profile/pin
 * @param {Object} req.body
 * @param {string} req.body.pin - PIN (4-6 digits)
 * @returns {Promise<{success: boolean, message: string}>} 200 - Success response
 * @returns {Promise<{error: string}>} 400 - Invalid PIN format
 * @returns {Promise<{error: string}>} 401 - Authentication required
 * @returns {Promise<{error: string}>} 500 - Server error
 */
router.post("/pin", requireUser, async (req, res) => {
  try {
    const { pin } = req.body;
    const userId = req.user.user_id;
    
    if (!pin || pin.length < 4 || pin.length > 6 || !/^\d+$/.test(pin)) {
      return res.status(400).json({ error: "PIN must be 4-6 digits" });
    }
    
    const pinHash = crypto.createHash("sha256").update(pin).digest("hex");
    
    await pool.query(
      "UPDATE users SET pin_hash = $1, updated_at = CURRENT_TIMESTAMP WHERE user_id = $2",
      [pinHash, userId]
    );
    
    res.status(200).json({ success: true, message: "PIN set successfully" });
  } catch (error) {
    console.error("Error setting PIN:", error);
    res.status(500).json({ 
      error: "Failed to set PIN",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});

/**
 * POST /api/profile/verify-pin
 * Verify PIN
 * 
 * @route POST /api/profile/verify-pin
 * @param {Object} req.body
 * @param {string} req.body.pin - PIN to verify
 * @returns {Promise<{success: boolean, message?: string}>} 200 - Success response
 * @returns {Promise<{error: string}>} 401 - Authentication required
 * @returns {Promise<{error: string}>} 500 - Server error
 */
router.post("/verify-pin", requireUser, async (req, res) => {
  try {
    const { pin } = req.body;
    const user = req.user;
    
    if (!user.pin_hash) {
      return res.json({ success: false, message: "PIN not set" });
    }
    
    const hash = crypto.createHash("sha256").update(pin).digest("hex");
    const isValid = crypto.timingSafeEqual(
      Buffer.from(hash),
      Buffer.from(user.pin_hash)
    );
    
    res.status(200).json({ success: isValid });
  } catch (error) {
    console.error("Error verifying PIN:", error);
    res.status(500).json({ 
      error: "Failed to verify PIN",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});


=== ROUTES: drops.js ===

--- routes/drops.js (1-260) ---
import express from "express";
import pool from "../utils/db.js";
import { classifyRawDrop, processPendingRawDrops } from "../services/dropsAI.js";
import { notifyNewDrop } from "../services/dropsNotifications.js";
import { getUserFromRequest } from "../middleware/userAuth.js";
import { logger } from "../bot/utils/logger.js";

const router = express.Router();

/**
 * POST /api/drops/intake
 * Universal intake endpoint for all sources (Discord, Telegram, site form)
 */
router.post("/intake", async (req, res) => {
  try {
    const { source, source_channel_id, source_user_id, source_username, raw_text, metadata = {} } = req.body;

    // Validation
    if (!source || !['discord', 'telegram_group', 'telegram_dm', 'site_form'].includes(source)) {
      return res.status(400).json({ error: "Invalid source. Must be: discord, telegram_group, telegram_dm, or site_form" });
    }

    if (!source_user_id || !raw_text) {
      return res.status(400).json({ error: "Missing required fields: source_user_id, raw_text" });
    }

    // PRIVACY ENFORCEMENT: For Discord source, ensure no Discord metadata is stored
    // The Discord bot should have already sanitized, but double-check here
    let sanitizedMetadata = { ...metadata };
    if (source === 'discord') {
      // Remove any Discord-specific metadata that might have leaked through
      delete sanitizedMetadata.discord_guild_id;
      delete sanitizedMetadata.discord_channel_name;
      delete sanitizedMetadata.discord_message_id;
      delete sanitizedMetadata.discord_user_id;
      delete sanitizedMetadata.discord_username;
      // Only keep sanitized context messages if present
      if (metadata.messages_before || metadata.messages_after) {
        sanitizedMetadata = {
          messages_before: metadata.messages_before || [],
          messages_after: metadata.messages_after || []
        };
      } else {
        sanitizedMetadata = {};
      }
    }

    // IDEMPOTENCY: Check for duplicate within last 1 hour (same source, same text)
    const duplicateCheck = await pool.query(
      `SELECT id, status FROM raw_drops 
       WHERE source = $1 
       AND raw_text = $2 
       AND created_at > NOW() - INTERVAL '1 hour'
       ORDER BY created_at DESC
       LIMIT 1`,
      [source, raw_text]
    );

    if (duplicateCheck.rows.length > 0) {
      const existing = duplicateCheck.rows[0];
      logger.info(`Duplicate raw drop detected (id: ${existing.id}), returning existing`);
      return res.status(200).json({
        success: true,
        raw_drop: existing,
        message: "Duplicate detected, returning existing raw drop",
        duplicate: true
      });
    }

    // Extract URLs and codes from raw text
    // For Discord with context, also check context messages
    let combinedText = raw_text;
    if (source === 'discord' && sanitizedMetadata.messages_before) {
      // Combine context for better extraction
      const contextText = [
        ...(sanitizedMetadata.messages_before || []),
        raw_text,
        ...(sanitizedMetadata.messages_after || [])
      ].join(' ');
      combinedText = contextText;
    }

    const urlRegex = /(https?:\/\/[^\s]+)/gi;
    const rawUrls = (combinedText.match(urlRegex) || []).map(url => url.trim().replace(/[.,;!?]+$/, ''));

    const codePatterns = [
      /\b[A-Z]{3,15}\d{2,10}\b/g,
      /\b[A-Z]{4,20}\b/g,
    ];
    const bonusCodeCandidates = new Set();
    codePatterns.forEach(pattern => {
      const matches = combinedText.match(pattern);
      if (matches) {
        matches.forEach(match => {
          if (match.length >= 4 && match.length <= 20) {
            bonusCodeCandidates.add(match.toUpperCase());
          }
        });
      }
    });

    // Create raw drop (ATOMIC: Single transaction)
    // Store sanitized metadata (including context messages) in the meta JSONB column
    const result = await pool.query(
      `INSERT INTO raw_drops (
        source, source_channel_id, source_user_id, source_username,
        raw_text, raw_urls, bonus_code_candidates, meta
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING *`,
      [
        source,
        source_channel_id || null,
        source_user_id,
        source_username || null,
        raw_text,
        rawUrls,
        Array.from(bonusCodeCandidates),
        sanitizedMetadata // Store in meta JSONB for context messages and easier querying
      ]
    );

    const rawDrop = result.rows[0];

    // Trigger AI classification asynchronously
    classifyRawDrop(rawDrop.id).catch(err => {
      logger.error(`Error classifying raw drop ${rawDrop.id}:`, err);
    });

    res.status(201).json({
      success: true,
      raw_drop: rawDrop,
      message: "Raw drop created and queued for AI classification"
    });

  } catch (error) {
    logger.error("Error creating raw drop:", error);
    res.status(500).json({ error: "Failed to create raw drop" });
  }
});

/**
 * GET /api/drops/promo-candidates
 * Get promo candidates for admin review (inbox)
 */
router.get("/promo-candidates", async (req, res) => {
  try {
    const { status = 'pending', limit = 50, offset = 0, casino_id, jurisdiction } = req.query;

    let query = `
      SELECT 
        pc.*,
        rd.source, rd.source_username, rd.raw_text, rd.created_at as submitted_at,
        acs.confidence_score, acs.guessed_casino, acs.guessed_jurisdiction,
        am.name as mapped_casino_name, am.icon_url as mapped_casino_logo, am.affiliate_url as mapped_casino_affiliate_url
      FROM promo_candidates pc
      JOIN raw_drops rd ON pc.raw_drop_id = rd.id
      JOIN ai_classification_snapshots acs ON pc.ai_snapshot_id = acs.id
      LEFT JOIN affiliates_master am ON pc.mapped_casino_id = am.id
      WHERE pc.status = $1
    `;

    const params = [status];
    let paramIndex = 2;

    if (casino_id) {
      query += ` AND pc.mapped_casino_id = $${paramIndex++}`;
      params.push(casino_id);
    }

    if (jurisdiction) {
      query += ` AND $${paramIndex++} = ANY(pc.jurisdiction_tags)`;
      params.push(jurisdiction);
    }

    query += ` ORDER BY rd.created_at DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;
    params.push(parseInt(limit), parseInt(offset));

    const result = await pool.query(query, params);

    const countResult = await pool.query(
      `SELECT COUNT(*) FROM promo_candidates WHERE status = $1`,
      [status]
    );

    res.json({
      candidates: result.rows,
      total: parseInt(countResult.rows[0].count),
      limit: parseInt(limit),
      offset: parseInt(offset)
    });

  } catch (error) {
    logger.error("Error fetching promo candidates:", error);
    res.status(500).json({ error: "Failed to fetch promo candidates" });
  }
});

/**
 * POST /api/drops/promo-candidates/:id/approve
 * Admin approves a promo candidate (creates DropPromo)
 */
router.post("/promo-candidates/:id/approve", async (req, res) => {
  try {
    const user = await getUserFromRequest(req);
    if (!user) {
      return res.status(401).json({ error: "Authentication required" });
    }

    const { id } = req.params;
    const { 
      headline, description, bonus_code, promo_url, mapped_casino_id, 
      jurisdiction_tags, quick_signup_url 
    } = req.body;

    // Get promo candidate
    const candidateResult = await pool.query(
      `SELECT pc.*, rd.id as raw_drop_id 
       FROM promo_candidates pc
       JOIN raw_drops rd ON pc.raw_drop_id = rd.id
       WHERE pc.id = $1`,
      [id]
    );

    if (candidateResult.rows.length === 0) {
      return res.status(404).json({ error: "Promo candidate not found" });
    }

    const candidate = candidateResult.rows[0];

    // Get affiliate URL if casino is mapped
    let finalQuickSignupUrl = quick_signup_url;
    if (mapped_casino_id && !finalQuickSignupUrl) {
      const affiliateResult = await pool.query(
        'SELECT affiliate_url FROM affiliates_master WHERE id = $1',
        [mapped_casino_id]
      );
      if (affiliateResult.rows.length > 0) {
        finalQuickSignupUrl = affiliateResult.rows[0].affiliate_url;
      }
    }

    // Create drop promo
    const promoResult = await pool.query(
      `INSERT INTO drop_promos (
        headline, description, promo_type, bonus_code, promo_url,
        resolved_domain, mapped_casino_id, jurisdiction_tags,
        quick_signup_url, source_raw_drop_id, source_promo_candidate_id,
        validity_flags, audit_trail
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
      RETURNING *`,
      [
        headline || candidate.headline,
        description || candidate.description,
        candidate.promo_type,
        bonus_code || candidate.bonus_code,
        promo_url || candidate.promo_url,
        candidate.resolved_domain,
        mapped_casino_id || candidate.mapped_casino_id,
        jurisdiction_tags || candidate.jurisdiction_tags || [],
        finalQuickSignupUrl,

=== ROUTES: newsletter.js ===

--- routes/newsletter.js (1-260) ---
import express from "express";
import pool from "../utils/db.js";
import { getUserFromRequest } from "../middleware/userAuth.js";

const router = express.Router();

// Initialize MailerSend if API key is available
let MailerSend = null;
let mailerSendClient = null;
if (process.env.MAILERSEND_API_KEY && process.env.GCZ_MAIL_PROVIDER === 'mailersend') {
  try {
    MailerSend = (await import("mailersend")).default;
    mailerSendClient = new MailerSend({
      api_key: process.env.MAILERSEND_API_KEY,
    });
  } catch (error) {
    console.error("Failed to initialize MailerSend:", error);
  }
}

// POST /api/newsletter/subscribe - Subscribe to newsletter
router.post("/subscribe", async (req, res) => {
  try {
    const { email } = req.body;
    const user = await getUserFromRequest(req);
    
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }
    
    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: "Invalid email format" });
    }
    
    // Write to database
    try {
      await pool.query(
        `INSERT INTO newsletter_subscribers (user_id, email, unsubscribed, created_at, updated_at)
         VALUES ($1, $2, false, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
         ON CONFLICT (email) 
         DO UPDATE SET 
           unsubscribed = false,
           user_id = COALESCE(EXCLUDED.user_id, newsletter_subscribers.user_id),
           updated_at = CURRENT_TIMESTAMP`,
        [user?.user_id || null, email]
      );
    } catch (dbError) {
      console.error("Database error storing newsletter subscription:", dbError);
      return res.status(500).json({ error: "Failed to store subscription" });
    }
    
    // Add to MailerSend mailing list (if configured)
    if (mailerSendClient && process.env.MAILERSEND_LIST_ID) {
      try {
        // Note: This requires a mailing list ID configured in MailerSend
        // For now, we'll just log that it should be added
        console.log("Newsletter subscription should be added to MailerSend list:", email);
        // TODO: Implement MailerSend recipient addition when list ID is available
      } catch (mailError) {
        console.error("MailerSend error (non-critical):", mailError);
        // Continue even if MailerSend fails
      }
    }
    
    res.status(200).json({ success: true, status: "subscribed" });
  } catch (error) {
    console.error("Error subscribing to newsletter:", error);
    res.status(500).json({ error: "Failed to subscribe" });
  }
});

// POST /api/newsletter/unsubscribe - Unsubscribe from newsletter
router.post("/unsubscribe", async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }
    
    // Update database
    await pool.query(
      `UPDATE newsletter_subscribers 
       SET unsubscribed = true, updated_at = CURRENT_TIMESTAMP 
       WHERE email = $1`,
      [email]
    );
    
    res.status(200).json({ success: true, status: "unsubscribed" });
  } catch (error) {
    console.error("Error unsubscribing from newsletter:", error);
    res.status(500).json({ error: "Failed to unsubscribe" });
  }
});

export default router;

=== ROUTES DIRECTORY LISTING ===

--- ls routes ---
activity.js
admin
admin.js
ads.js
affiliates.js
analytics.js
api.js
blacklist.js
casino.js
contact.js
dailySpin.js
dashboard.js
drops.js
gamification.js
giveaways.js
liveDashboard.js
newsletter.js
notifications.js
profile.js
promos.js
push.js
raffles.js
rafflesExtended.js
realtime.js
sites.js
socials.js
stats.js

=== ROUTES: admin.js ===

--- routes/admin.js (1-260) ---
import express from "express";
import adminAuth from "../middleware/adminAuth.js";
import adminUsers from "./admin/users.js";
import adminRaffles from "./admin/raffles.js";
import adminAffiliates from "./admin/affiliates.js";
import adminRedirects from "./admin/redirects.js";
import adminAds from "./admin/ads.js";
import adminBlacklist from "./admin/blacklist.js";
import adminLiveBanner from "./admin/liveBanner.js";
import adminSettings from "./admin/settings.js";
import adminDailyDrops from "./admin/dailyDrops.js";
import adminPush from "./admin/push.js";
import adminWheel from "./admin/wheel.js";
import adminNewsletter from "./admin/newsletter.js";
import adminAdsDashboard from "./admin/adsDashboard.js";
import adminTelegramBot from "./admin/telegramBot.js";
import adminOverrides from "./admin/overrides.js";
import adminGiveaways from "./admin/giveaways.js";
import adminAffiliateAnalytics from "./admin/affiliateAnalytics.js";
import adminAuthRoutes from "./admin/auth.js";
import adminAdminUsers from "./admin/adminUsers.js";
import adminHealth from "./admin/health.js";

const router = express.Router();

// Auth routes (no auth required for login)
router.use("/auth", adminAuthRoutes);

// All other admin routes require authentication
router.use(adminAuth);

// Mount admin sub-routes
router.use("/users", adminUsers);
router.use("/raffles", adminRaffles);
router.use("/affiliates", adminAffiliates);
router.use("/sites", adminAffiliates); // Alias for semantic clarity
router.use("/redirects", adminRedirects);
router.use("/ads", adminAds);
router.use("/blacklist", adminBlacklist);
router.use("/live-banner", adminLiveBanner);
router.use("/settings", adminSettings);
router.use("/daily-drops", adminDailyDrops);
router.use("/push", adminPush);
router.use("/wheel", adminWheel);
router.use("/newsletter", adminNewsletter);
router.use("/ads-dashboard", adminAdsDashboard);
router.use("/telegram-bot", adminTelegramBot);
router.use("/overrides", adminOverrides);
router.use("/giveaways", adminGiveaways);
router.use("/affiliate-analytics", adminAffiliateAnalytics);
router.use("/admin-users", adminAdminUsers);
router.use("/health", adminHealth);

// Warmup endpoint (moved from redirects sub-router)
router.post("/warmup", async (req, res) => {
  try {
    const pkg = await import("pg");
    const { Pool } = pkg;
    const pool = new Pool({ connectionString: process.env.DATABASE_URL });
    
    const redirectsResult = await pool.query("SELECT slug FROM redirects ORDER BY weight DESC");
    
    // TODO: Implement actual warmup logic
    res.json({
      success: true,
      message: "Warmup triggered",
      redirects_count: redirectsResult.rows.length
    });
  } catch (error) {
    console.error("Error triggering warmup:", error);
    res.status(500).json({ error: "Failed to trigger warmup" });
  }
});

export default router;

=== ROUTES: auth.js (if exists) ===
[INFO] routes/auth.js not found (might be in profile/admin)

=== DB SCHEMA: users / drop_promos / drops ===

--- \d users ---
                                            Table "public.users"
      Column       |            Type             | Collation | Nullable |              Default              
-------------------+-----------------------------+-----------+----------+-----------------------------------
 id                | integer                     |           | not null | nextval('users_id_seq'::regclass)
 user_id           | text                        |           | not null | 
 pin_hash          | text                        |           |          | 
 locked            | boolean                     |           |          | false
 telegram_id       | text                        |           |          | 
 telegram_username | text                        |           |          | 
 cwallet_id        | text                        |           |          | 
 email             | text                        |           |          | 
 username          | text                        |           |          | 
 jurisdiction      | text                        |           |          | 
 created_at        | timestamp without time zone |           |          | CURRENT_TIMESTAMP
 updated_at        | timestamp without time zone |           |          | CURRENT_TIMESTAMP
Indexes:
    "users_pkey" PRIMARY KEY, btree (id)
    "idx_users_cwallet_id" btree (cwallet_id)
    "idx_users_email" btree (email)
    "idx_users_telegram_id" btree (telegram_id)
    "idx_users_user_id" btree (user_id)
    "users_user_id_key" UNIQUE CONSTRAINT, btree (user_id)


--- \d drop_promos ---
                                              Table "public.drop_promos"
          Column           |           Type           | Collation | Nullable |                 Default                 
---------------------------+--------------------------+-----------+----------+-----------------------------------------
 id                        | bigint                   |           | not null | nextval('drop_promos_id_seq'::regclass)
 promo_candidate_id        | bigint                   |           | not null | 
 raw_drop_id               | bigint                   |           | not null | 
 affiliate_id              | integer                  |           |          | 
 promo_code                | text                     |           |          | 
 promo_description         | text                     |           |          | 
 promo_url                 | text                     |           |          | 
 jurisdiction              | text                     |           |          | 
 casino_name               | text                     |           |          | 
 approved_at               | timestamp with time zone |           |          | 
 approved_by               | text                     |           |          | 
 is_active                 | boolean                  |           |          | true
 is_featured               | boolean                  |           |          | false
 created_at                | timestamp with time zone |           |          | CURRENT_TIMESTAMP
 updated_at                | timestamp with time zone |           |          | CURRENT_TIMESTAMP
 ai_notes                  | jsonb                    |           |          | '{}'::jsonb
 status                    | text                     |           |          | 'active'::text
 source_raw_drop_id        | bigint                   |           |          | 
 source_promo_candidate_id | bigint                   |           |          | 
 headline                  | text                     |           |          | 
 description               | text                     |           |          | 
 promo_type                | text                     |           |          | 
 bonus_code                | text                     |           |          | 
 resolved_domain           | text                     |           |          | 
 mapped_casino_id          | integer                  |           |          | 
 jurisdiction_tags         | text[]                   |           |          | 
 quick_signup_url          | text                     |           |          | 
 validity_flags            | jsonb                    |           |          | '{}'::jsonb
 audit_trail               | jsonb                    |           |          | '[]'::jsonb
 featured                  | boolean                  |           |          | false
 view_count                | integer                  |           |          | 0
 click_count               | integer                  |           |          | 0
 expires_at                | timestamp with time zone |           |          | 
Indexes:
    "drop_promos_pkey" PRIMARY KEY, btree (id)
    "idx_drop_promos_affiliate_id" btree (affiliate_id)
    "idx_drop_promos_candidate_id" btree (promo_candidate_id)
    "idx_drop_promos_expires_at" btree (expires_at)
    "idx_drop_promos_featured" btree (featured)
    "idx_drop_promos_is_active" btree (is_active)
    "idx_drop_promos_is_featured" btree (is_featured)
    "idx_drop_promos_jurisdiction_tags" gin (jurisdiction_tags)
    "idx_drop_promos_mapped_casino_id" btree (mapped_casino_id)
    "idx_drop_promos_status" btree (status)
Check constraints:
    "drop_promos_jurisdiction_check" CHECK (jurisdiction IS NULL OR jurisdiction <> ''::text)
    "drop_promos_promo_type_check" CHECK (promo_type IS NULL OR (promo_type = ANY (ARRAY['code'::text, 'url'::text, 'hybrid'::text, 'info_only'::text])))
    "drop_promos_status_check" CHECK (status = ANY (ARRAY['active'::text, 'inactive'::text, 'expired'::text, 'archived'::text]))
Foreign-key constraints:
    "drop_promos_affiliate_fk" FOREIGN KEY (affiliate_id) REFERENCES affiliates_master(id) ON DELETE SET NULL
    "drop_promos_affiliate_id_fkey" FOREIGN KEY (affiliate_id) REFERENCES affiliates_master(id) ON DELETE SET NULL
    "drop_promos_candidate_fk" FOREIGN KEY (promo_candidate_id) REFERENCES promo_candidates(id) ON DELETE CASCADE
    "drop_promos_mapped_casino_fk" FOREIGN KEY (mapped_casino_id) REFERENCES affiliates_master(id) ON DELETE SET NULL
    "drop_promos_promo_candidate_id_fkey" FOREIGN KEY (promo_candidate_id) REFERENCES promo_candidates(id) ON DELETE CASCADE
    "drop_promos_raw_drop_fk" FOREIGN KEY (raw_drop_id) REFERENCES raw_drops(id) ON DELETE CASCADE
    "drop_promos_raw_drop_id_fkey" FOREIGN KEY (raw_drop_id) REFERENCES raw_drops(id) ON DELETE CASCADE
Referenced by:
    TABLE "drop_notifications_sent" CONSTRAINT "drop_notifications_sent_drop_promo_id_fkey" FOREIGN KEY (drop_promo_id) REFERENCES drop_promos(id) ON DELETE CASCADE
    TABLE "drop_notifications_sent" CONSTRAINT "drop_notifications_sent_promo_fk" FOREIGN KEY (drop_promo_id) REFERENCES drop_promos(id) ON DELETE CASCADE
    TABLE "drop_user_reports" CONSTRAINT "drop_user_reports_drop_promo_id_fkey" FOREIGN KEY (drop_promo_id) REFERENCES drop_promos(id) ON DELETE CASCADE
    TABLE "drop_user_reports" CONSTRAINT "drop_user_reports_promo_fk" FOREIGN KEY (drop_promo_id) REFERENCES drop_promos(id) ON DELETE CASCADE
Triggers:
    trg_drop_promos_updated_at BEFORE UPDATE ON drop_promos FOR EACH ROW EXECUTE FUNCTION update_timestamp()


--- \d drops ---
Did not find any relation named "drops".

=== API ENDPOINT PROBES ===

--- curl /api/drops ---
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 72.60.113.42:443...
* Connected to gamblecodez.com (72.60.113.42) port 443 (#0)
* ALPN, offering h2
* ALPN, offering http/1.1
*  CAfile: /etc/ssl/certs/ca-certificates.crt
*  CApath: /etc/ssl/certs
* TLSv1.0 (OUT), TLS header, Certificate Status (22):
} [5 bytes data]
* TLSv1.3 (OUT), TLS handshake, Client hello (1):
} [512 bytes data]
* TLSv1.2 (IN), TLS header, Certificate Status (22):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Server hello (2):
{ [122 bytes data]
* TLSv1.2 (IN), TLS header, Finished (20):
{ [5 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):
{ [19 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Certificate (11):
{ [2615 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, CERT verify (15):
{ [264 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Finished (20):
{ [52 bytes data]
* TLSv1.2 (OUT), TLS header, Finished (20):
} [5 bytes data]
* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):
} [1 bytes data]
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.3 (OUT), TLS handshake, Finished (20):
} [52 bytes data]
* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384
* ALPN, server accepted to use h2
* Server certificate:
*  subject: CN=gamblecodez.com
*  start date: Dec 29 19:18:06 2025 GMT
*  expire date: Mar 29 19:18:05 2026 GMT
*  subjectAltName: host "gamblecodez.com" matched cert's "gamblecodez.com"
*  issuer: C=US; O=Let's Encrypt; CN=R13
*  SSL certificate verify ok.
* Using HTTP2, server supports multiplexing
* Connection state changed (HTTP/2 confirmed)
* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* Using Stream ID: 1 (easy handle 0x55d8a32969f0)
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
> GET /api/drops HTTP/2
> Host: gamblecodez.com
> user-agent: curl/7.81.0
> accept: */*
> 
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
{ [265 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
{ [265 bytes data]
* old SSL session ID is stale, removing
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* Connection state changed (MAX_CONCURRENT_STREAMS == 128)!
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
< HTTP/2 404 
< server: nginx
< date: Thu, 01 Jan 2026 06:33:05 GMT
< content-type: text/html; charset=utf-8
< content-length: 148
< x-powered-by: Express
< x-content-type-options: nosniff
< x-frame-options: DENY
< x-xss-protection: 1; mode=block
< referrer-policy: strict-origin-when-cross-origin
< permissions-policy: geolocation=(), microphone=(), camera=()
< content-security-policy: default-src 'none'
< strict-transport-security: max-age=31536000; includeSubDomains
< x-ratelimit-limit: 100
< x-ratelimit-remaining: 89
< x-ratelimit-reset: 2026-01-01T06:40:19.492Z
< access-control-allow-origin: *
< strict-transport-security: max-age=31536000; includeSubDomains; preload
< x-frame-options: SAMEORIGIN
< x-content-type-options: nosniff
< x-xss-protection: 1; mode=block
< referrer-policy: strict-origin-when-cross-origin
< content-security-policy: default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https: wss:; frame-ancestors 'self';
< 
{ [148 bytes data]
100   148  100   148    0     0   2772      0 --:--:-- --:--:-- --:--:--  2792
* Connection #0 to host gamblecodez.com left intact
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Error</title>
</head>
<body>
<pre>Cannot GET /api/drops</pre>
</body>
</html>

--- curl /api/profile/me (no auth) ---
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 72.60.113.42:443...
* Connected to gamblecodez.com (72.60.113.42) port 443 (#0)
* ALPN, offering h2
* ALPN, offering http/1.1
*  CAfile: /etc/ssl/certs/ca-certificates.crt
*  CApath: /etc/ssl/certs
* TLSv1.0 (OUT), TLS header, Certificate Status (22):
} [5 bytes data]
* TLSv1.3 (OUT), TLS handshake, Client hello (1):
} [512 bytes data]
* TLSv1.2 (IN), TLS header, Certificate Status (22):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Server hello (2):
{ [122 bytes data]
* TLSv1.2 (IN), TLS header, Finished (20):
{ [5 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):
{ [19 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Certificate (11):
{ [2615 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, CERT verify (15):
{ [264 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Finished (20):
{ [52 bytes data]
* TLSv1.2 (OUT), TLS header, Finished (20):
} [5 bytes data]
* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):
} [1 bytes data]
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.3 (OUT), TLS handshake, Finished (20):
} [52 bytes data]
* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384
* ALPN, server accepted to use h2
* Server certificate:
*  subject: CN=gamblecodez.com
*  start date: Dec 29 19:18:06 2025 GMT
*  expire date: Mar 29 19:18:05 2026 GMT
*  subjectAltName: host "gamblecodez.com" matched cert's "gamblecodez.com"
*  issuer: C=US; O=Let's Encrypt; CN=R13
*  SSL certificate verify ok.
* Using HTTP2, server supports multiplexing
* Connection state changed (HTTP/2 confirmed)
* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* Using Stream ID: 1 (easy handle 0x555b6f2c89f0)
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
> GET /api/profile/me HTTP/2
> Host: gamblecodez.com
> user-agent: curl/7.81.0
> accept: */*
> 
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
{ [265 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
{ [265 bytes data]
* old SSL session ID is stale, removing
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* Connection state changed (MAX_CONCURRENT_STREAMS == 128)!
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
< HTTP/2 404 
< server: nginx
< date: Thu, 01 Jan 2026 06:33:05 GMT
< content-type: text/html; charset=utf-8
< content-length: 153
< x-powered-by: Express
< x-content-type-options: nosniff
< x-frame-options: DENY
< x-xss-protection: 1; mode=block
< referrer-policy: strict-origin-when-cross-origin
< permissions-policy: geolocation=(), microphone=(), camera=()
< content-security-policy: default-src 'none'
< strict-transport-security: max-age=31536000; includeSubDomains
< x-ratelimit-limit: 100
< x-ratelimit-remaining: 88
< x-ratelimit-reset: 2026-01-01T06:40:19.492Z
< access-control-allow-origin: *
< strict-transport-security: max-age=31536000; includeSubDomains; preload
< x-frame-options: SAMEORIGIN
< x-content-type-options: nosniff
< x-xss-protection: 1; mode=block
< referrer-policy: strict-origin-when-cross-origin
< content-security-policy: default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https: wss:; frame-ancestors 'self';
< 
{ [153 bytes data]
100   153  100   153    0     0   3106      0 --:--:-- --:--:-- --:--:--  3122
* Connection #0 to host gamblecodez.com left intact
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Error</title>
</head>
<body>
<pre>Cannot GET /api/profile/me</pre>
</body>
</html>

--- curl /api/auth/login (no payload) ---
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 72.60.113.42:443...
* Connected to gamblecodez.com (72.60.113.42) port 443 (#0)
* ALPN, offering h2
* ALPN, offering http/1.1
*  CAfile: /etc/ssl/certs/ca-certificates.crt
*  CApath: /etc/ssl/certs
* TLSv1.0 (OUT), TLS header, Certificate Status (22):
} [5 bytes data]
* TLSv1.3 (OUT), TLS handshake, Client hello (1):
} [512 bytes data]
* TLSv1.2 (IN), TLS header, Certificate Status (22):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Server hello (2):
{ [122 bytes data]
* TLSv1.2 (IN), TLS header, Finished (20):
{ [5 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):
{ [19 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Certificate (11):
{ [2615 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, CERT verify (15):
{ [264 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Finished (20):
{ [52 bytes data]
* TLSv1.2 (OUT), TLS header, Finished (20):
} [5 bytes data]
* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):
} [1 bytes data]
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.3 (OUT), TLS handshake, Finished (20):
} [52 bytes data]
* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384
* ALPN, server accepted to use h2
* Server certificate:
*  subject: CN=gamblecodez.com
*  start date: Dec 29 19:18:06 2025 GMT
*  expire date: Mar 29 19:18:05 2026 GMT
*  subjectAltName: host "gamblecodez.com" matched cert's "gamblecodez.com"
*  issuer: C=US; O=Let's Encrypt; CN=R13
*  SSL certificate verify ok.
* Using HTTP2, server supports multiplexing
* Connection state changed (HTTP/2 confirmed)
* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* Using Stream ID: 1 (easy handle 0x55615607d9f0)
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
> GET /api/auth/login HTTP/2
> Host: gamblecodez.com
> user-agent: curl/7.81.0
> accept: */*
> 
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
{ [265 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
{ [265 bytes data]
* old SSL session ID is stale, removing
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* Connection state changed (MAX_CONCURRENT_STREAMS == 128)!
* TLSv1.2 (OUT), TLS header, Supplemental data (23):
} [5 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
* TLSv1.2 (IN), TLS header, Supplemental data (23):
{ [5 bytes data]
< HTTP/2 404 
< server: nginx
< date: Thu, 01 Jan 2026 06:33:05 GMT
< content-type: text/html; charset=utf-8
< content-length: 153
< x-powered-by: Express
< x-content-type-options: nosniff
< x-frame-options: DENY
< x-xss-protection: 1; mode=block
< referrer-policy: strict-origin-when-cross-origin
< permissions-policy: geolocation=(), microphone=(), camera=()
< content-security-policy: default-src 'none'
< strict-transport-security: max-age=31536000; includeSubDomains
< x-ratelimit-limit: 100
< x-ratelimit-remaining: 87
< x-ratelimit-reset: 2026-01-01T06:40:19.492Z
< access-control-allow-origin: *
< strict-transport-security: max-age=31536000; includeSubDomains; preload
< x-frame-options: SAMEORIGIN
< x-content-type-options: nosniff
< x-xss-protection: 1; mode=block
< referrer-policy: strict-origin-when-cross-origin
< content-security-policy: default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https: wss:; frame-ancestors 'self';
< 
{ [153 bytes data]
100   153  100   153    0     0   3061      0 --:--:-- --:--:-- --:--:--  3122
* Connection #0 to host gamblecodez.com left intact
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Error</title>
</head>
<body>
<pre>Cannot GET /api/auth/login</pre>
</body>
</html>

=== GCZ FULL SYSTEM REPORT COMPLETE ===
Report saved to: /var/www/html/gcz/gcz-report.txt
